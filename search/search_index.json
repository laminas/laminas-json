{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-json Laminas\\Json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site . Installation Run the following to install this library: $ composer require laminas/laminas-json Documentation Browse the documentation online at https://docs.laminas.dev/laminas-json/ Support Issues Chat Forum","title":"Home"},{"location":"#laminas-json","text":"Laminas\\Json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site .","title":"laminas-json"},{"location":"#installation","text":"Run the following to install this library: $ composer require laminas/laminas-json","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.laminas.dev/laminas-json/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"advanced/","text":"Advanced Usage JSON Objects When encoding PHP objects as JSON, all public properties of that object will be encoded in a JSON object. JSON does not allow object references, so care should be taken not to encode objects with recursive references. If you have issues with recursion, Laminas\\Json\\Json::encode() and Laminas\\Json\\Encoder::encode() each allow an optional second parameter to check for recursion; if an object is serialized twice, an exception will be thrown. Decoding JSON objects poses additional difficulty, however, since JavaScript objects correspond most closely to PHP's associative array. Some suggest that a class identifier should be passed, and an object instance of that class should be created and populated with the key/value pairs of the JSON object; others feel this could pose a substantial security risk. By default, Laminas\\Json\\Json will decode JSON objects as stdClass objects. However, if you desire an associative array returned, you can request it using the second argument to decode() : // Decode JSON objects as PHP array $phpNative = Laminas\\Json\\Json::decode($encodedValue, Laminas\\Json\\Json::TYPE_ARRAY); Any objects thus decoded are returned as associative arrays with keys and values corresponding to the key/value pairs in the JSON notation. The recommendation of Laminas is that the individual developer should decide how to decode JSON objects. If an object of a specified type should be created, it can be created in the developer code and populated with the values decoded using laminas-json. Encoding PHP Objects If you are encoding PHP objects, the default encoding mechanism can only access public properties of these objects. When a method toJson() is implemented on an object to encode, Laminas\\Json\\Json calls this method and expects the object to return a JSON representation of its internal state. Laminas\\Json\\Json can encode PHP objects recursively but does not do so by default. This can be enabled by passing true as the second argument to Laminas\\Json\\Json::encode() . // Encode PHP object recursively $jsonObject = Laminas\\Json\\Json::encode($data, true); When doing recursive encoding of objects, as JSON does not support cycles, a Laminas\\Json\\Exception\\RecursionException will be thrown. If you wish, you can silence these exceptions by passing the silenceCyclicalExceptions option: $jsonObject = Laminas\\Json\\Json::encode( $data, true, ['silenceCyclicalExceptions' => true] ); Internal Encoder/Decoder Laminas\\Json has two different modes depending if ext/json is enabled in your PHP installation or not. If ext/json is installed, laminas-json will use the json_encode() and json_decode() functions for encoding and decoding JSON. If ext/json is not installed, a Laminas implementation in PHP code is used for en/decoding. This is considerably slower than using the PHP extension, but behaves exactly the same. Sometimes you might want to use the laminas-json encoder/decoder even if you have ext/json installed. You can achieve this by calling: Laminas\\Json\\Json::$useBuiltinEncoderDecoder = true; JSON Expressions JavaScript makes heavy use of anonymous function callbacks, which can be saved within JSON object variables. They only work if not returned inside double quotes, which laminas-json implements by default. With the Expression support for laminas-json, you can encode JSON objects with valid JavaScript callbacks. This works when either json_encode() or the internal encoder is used. A JavaScript callback is represented using the Laminas\\Json\\Expr object. It implements the value object pattern and is immutable. You can set the JavaScript expression as the first constructor argument. By default Laminas\\Json\\Json::encode() does not encode JavaScript callbacks; you have to pass the option enableJsonExprFinder and set it to TRUE when calling the encode() method. If enabled, the expression support works for all nested expressions in large object structures. As an example: $data = [ 'onClick' => new Laminas\\Json\\Expr( 'function() {' . 'alert(\"I am a valid JavaScript callback created by Laminas\\\\Json\"); . '}' ), 'other' => 'no expression', ]; $jsonObjectWithExpression = Laminas\\Json\\Json::encode( $data, false, ['enableJsonExprFinder' => true] );","title":"Advanced Usage"},{"location":"advanced/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"advanced/#json-objects","text":"When encoding PHP objects as JSON, all public properties of that object will be encoded in a JSON object. JSON does not allow object references, so care should be taken not to encode objects with recursive references. If you have issues with recursion, Laminas\\Json\\Json::encode() and Laminas\\Json\\Encoder::encode() each allow an optional second parameter to check for recursion; if an object is serialized twice, an exception will be thrown. Decoding JSON objects poses additional difficulty, however, since JavaScript objects correspond most closely to PHP's associative array. Some suggest that a class identifier should be passed, and an object instance of that class should be created and populated with the key/value pairs of the JSON object; others feel this could pose a substantial security risk. By default, Laminas\\Json\\Json will decode JSON objects as stdClass objects. However, if you desire an associative array returned, you can request it using the second argument to decode() : // Decode JSON objects as PHP array $phpNative = Laminas\\Json\\Json::decode($encodedValue, Laminas\\Json\\Json::TYPE_ARRAY); Any objects thus decoded are returned as associative arrays with keys and values corresponding to the key/value pairs in the JSON notation. The recommendation of Laminas is that the individual developer should decide how to decode JSON objects. If an object of a specified type should be created, it can be created in the developer code and populated with the values decoded using laminas-json.","title":"JSON Objects"},{"location":"advanced/#encoding-php-objects","text":"If you are encoding PHP objects, the default encoding mechanism can only access public properties of these objects. When a method toJson() is implemented on an object to encode, Laminas\\Json\\Json calls this method and expects the object to return a JSON representation of its internal state. Laminas\\Json\\Json can encode PHP objects recursively but does not do so by default. This can be enabled by passing true as the second argument to Laminas\\Json\\Json::encode() . // Encode PHP object recursively $jsonObject = Laminas\\Json\\Json::encode($data, true); When doing recursive encoding of objects, as JSON does not support cycles, a Laminas\\Json\\Exception\\RecursionException will be thrown. If you wish, you can silence these exceptions by passing the silenceCyclicalExceptions option: $jsonObject = Laminas\\Json\\Json::encode( $data, true, ['silenceCyclicalExceptions' => true] );","title":"Encoding PHP Objects"},{"location":"advanced/#internal-encoderdecoder","text":"Laminas\\Json has two different modes depending if ext/json is enabled in your PHP installation or not. If ext/json is installed, laminas-json will use the json_encode() and json_decode() functions for encoding and decoding JSON. If ext/json is not installed, a Laminas implementation in PHP code is used for en/decoding. This is considerably slower than using the PHP extension, but behaves exactly the same. Sometimes you might want to use the laminas-json encoder/decoder even if you have ext/json installed. You can achieve this by calling: Laminas\\Json\\Json::$useBuiltinEncoderDecoder = true;","title":"Internal Encoder/Decoder"},{"location":"advanced/#json-expressions","text":"JavaScript makes heavy use of anonymous function callbacks, which can be saved within JSON object variables. They only work if not returned inside double quotes, which laminas-json implements by default. With the Expression support for laminas-json, you can encode JSON objects with valid JavaScript callbacks. This works when either json_encode() or the internal encoder is used. A JavaScript callback is represented using the Laminas\\Json\\Expr object. It implements the value object pattern and is immutable. You can set the JavaScript expression as the first constructor argument. By default Laminas\\Json\\Json::encode() does not encode JavaScript callbacks; you have to pass the option enableJsonExprFinder and set it to TRUE when calling the encode() method. If enabled, the expression support works for all nested expressions in large object structures. As an example: $data = [ 'onClick' => new Laminas\\Json\\Expr( 'function() {' . 'alert(\"I am a valid JavaScript callback created by Laminas\\\\Json\"); . '}' ), 'other' => 'no expression', ]; $jsonObjectWithExpression = Laminas\\Json\\Json::encode( $data, false, ['enableJsonExprFinder' => true] );","title":"JSON Expressions"},{"location":"basics/","text":"Basic Usage Usage of laminas-json involves using two public static methods: Laminas\\Json\\Json::encode() and Laminas\\Json\\Json::decode() . // Decode a JSON value to PHP: $phpNative = Laminas\\Json\\Json::decode($encodedValue); // Encode a PHP value to JSON: $json = Laminas\\Json\\Json::encode($phpNative); ext/json By default, the above two calls will proxy to the json_decode() and json_encode() functions of ext/json , which is bundled in default installations of PHP. Using laminas-json, however, ensures that the functionality works regardless of whether or not the extension is available. Additionally, the component provides some features not found in ext/json , such as encoding native JSON expressions, communicating class inheritance, and customizations around pretty printing. Pretty-printing JSON Sometimes, it may be hard to explore JSON data generated by Laminas\\Json\\Json::encode() , since it has no spacing or indentation. In order to make it easier, Laminas\\Json\\Json allows you to pretty-print JSON data in the human-readable format with Laminas\\Json\\Json::prettyPrint() . // Encode it to return to the client: $json = Laminas\\Json\\Json::encode($phpNative); if ($debug) { echo Laminas\\Json\\Json::prettyPrint($json, array('indent' => ' ')); } The second, optional, argument to Laminas\\Json\\Json::prettyPrint() is an option array. Option indent allows providing an indentation string; by default, it uses four spaces.","title":"Basic Usage"},{"location":"basics/#basic-usage","text":"Usage of laminas-json involves using two public static methods: Laminas\\Json\\Json::encode() and Laminas\\Json\\Json::decode() . // Decode a JSON value to PHP: $phpNative = Laminas\\Json\\Json::decode($encodedValue); // Encode a PHP value to JSON: $json = Laminas\\Json\\Json::encode($phpNative);","title":"Basic Usage"},{"location":"basics/#pretty-printing-json","text":"Sometimes, it may be hard to explore JSON data generated by Laminas\\Json\\Json::encode() , since it has no spacing or indentation. In order to make it easier, Laminas\\Json\\Json allows you to pretty-print JSON data in the human-readable format with Laminas\\Json\\Json::prettyPrint() . // Encode it to return to the client: $json = Laminas\\Json\\Json::encode($phpNative); if ($debug) { echo Laminas\\Json\\Json::prettyPrint($json, array('indent' => ' ')); } The second, optional, argument to Laminas\\Json\\Json::prettyPrint() is an option array. Option indent allows providing an indentation string; by default, it uses four spaces.","title":"Pretty-printing JSON"},{"location":"intro/","text":"Introduction laminas-json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site . JSON, JavaScript Object Notation, can be used for data interchange between JavaScript and other languages. Since JSON can be directly evaluated by JavaScript, it is a more efficient and lightweight format than XML for exchanging data with JavaScript clients.","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-json provides convenience methods for serializing native PHP to JSON and decoding JSON to native PHP. For more information on JSON, visit the JSON project site . JSON, JavaScript Object Notation, can be used for data interchange between JavaScript and other languages. Since JSON can be directly evaluated by JavaScript, it is a more efficient and lightweight format than XML for exchanging data with JavaScript clients.","title":"Introduction"},{"location":"migration/v2-to-v3/","text":"Migrating from v2 to v3 Version 3 is the first significant departure in the laminas-json API. In particular, it features the removal of two features to new packages. laminas-json-server The Laminas\\Json\\Server subcomponent was extracted to a new component, laminas-json-server . Install it using: $ composer install laminas/laminas-json-server All classes and functionality remain the same as in previous versions of laminas-json. XML to JSON support v2 releases of laminas-json provided Laminas\\Json\\Json::fromXml() , which could be used to convert an XML document to JSON. This functionality has been extracted to a new component, laminas-xml2json . Install it using: $ composer install laminas/laminas-xml2json In order to use the functionality, you will need to modify your calls from Laminas\\Json\\Json::fromXml() to instead use Laminas\\Xml2Json\\Xml2Json::fromXml() .","title":"From v2 to v3"},{"location":"migration/v2-to-v3/#migrating-from-v2-to-v3","text":"Version 3 is the first significant departure in the laminas-json API. In particular, it features the removal of two features to new packages.","title":"Migrating from v2 to v3"},{"location":"migration/v2-to-v3/#laminas-json-server","text":"The Laminas\\Json\\Server subcomponent was extracted to a new component, laminas-json-server . Install it using: $ composer install laminas/laminas-json-server All classes and functionality remain the same as in previous versions of laminas-json.","title":"laminas-json-server"},{"location":"migration/v2-to-v3/#xml-to-json-support","text":"v2 releases of laminas-json provided Laminas\\Json\\Json::fromXml() , which could be used to convert an XML document to JSON. This functionality has been extracted to a new component, laminas-xml2json . Install it using: $ composer install laminas/laminas-xml2json In order to use the functionality, you will need to modify your calls from Laminas\\Json\\Json::fromXml() to instead use Laminas\\Xml2Json\\Xml2Json::fromXml() .","title":"XML to JSON support"}]}